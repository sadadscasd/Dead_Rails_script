local AUTO_FARM_ENABLED = true
local CHECK_INTERVAL = 2
local MAX_FARM_TIME = 120

-- Инициализация глобальных переменных
if not getgenv().AutoFarmCore then
    getgenv().AutoFarmCore = {
        Settings = {
            AutoFarmEnabled = AUTO_FARM_ENABLED,
            CheckInterval = CHECK_INTERVAL,
            MaxFarmTime = MAX_FARM_TIME,
            TweenSpeed = 1000,
            CollectDelay = 0.01,
            GunSearchTimeout = 20,
            MaxErrors = 10,
            ErrorCooldown = 5,
            SafetyChecks = true
        },
        State = {
            Initialized = false,
            GamePlaceId = nil,
            IsInGame = false,
            FarmStartTime = 0,
            FarmTimerActive = false,
            WarningShown = false,
            ErrorCount = 0,
            LastErrorTime = 0,
            RetryCount = 0,
            MaxRetries = 5,
            KeyVerified = false,
            FirstRun = true,
            GitHubToken = "TOKEN_GIT",
            GitHubRepo = "sadadscasd/Dead_Rails_script",
            GitHubDataFile = "access_data.json"
        },
        Connections = {},
        Cache = {
            Services = {}
        },
        Constants = {
            BondName = "Bond",
            GunName = "MaximGun",
            RemotesPath = {"Remotes", "EndDecision"},
            ActivatePath = {"Shared", "Network", "RemotePromise", "Remotes", "C_ActivateObject"},
            GunCFrame = CFrame.new(350.5, 50.89, -9100.78),
            RangeMaxGun = 200,
            ErrorPatterns = {
                "attempt to iterate over a nil value",
                "WeaponController",
                "ReplicatedStorage.Client.Game.Controllers"
            },
            LocalDataFileName = "AutoFarm_LocalData.json"
        }
    }
end

local core = getgenv().AutoFarmCore
local settings = core.Settings
local state = core.State
local constants = core.Constants
local cache = core.Cache

-- Кэширование сервисов
cache.Services.Players = game:GetService("Players")
cache.Services.Workspace = game:GetService("Workspace")
cache.Services.TweenService = game:GetService("TweenService")
cache.Services.ReplicatedStorage = game:GetService("ReplicatedStorage")
cache.Services.RunService = game:GetService("RunService")
cache.Services.ScriptContext = game:GetService("ScriptContext")
cache.Services.UserInputService = game:GetService("UserInputService")
cache.Services.HttpService = game:GetService("HttpService")

local Players = cache.Services.Players
local Workspace = cache.Services.Workspace
local TweenService = cache.Services.TweenService
local ReplicatedStorage = cache.Services.ReplicatedStorage
local RunService = cache.Services.RunService
local ScriptContext = cache.Services.ScriptContext
local UserInputService = cache.Services.UserInputService
local HttpService = cache.Services.HttpService

-- Функция генерации уникального ключа
local function generateAccessKey(userId, username)
    local timestamp = os.time()
    local randomPart = math.random(10000, 99999)
    local baseString = userId .. username .. timestamp .. randomPart
    local hash = ""
    
    for i = 1, #baseString do
        local char = string.sub(baseString, i, i)
        local byte = string.byte(char)
        hash = hash .. string.format("%02X", byte)
    end
    
    -- Форматируем в вид KEY-XXXX-XXXX-XXXX
    local formattedKey = "KEY-"
    for i = 1, 12 do
        if i % 4 == 0 and i ~= 12 then
            formattedKey = formattedKey .. "-"
        end
        formattedKey = formattedKey .. string.sub(hash, i, i)
    end
    
    return formattedKey
end

-- Функция для работы с локальным JSON файлом
local function loadLocalData()
    local success, data = pcall(function()
        if isfile(constants.LocalDataFileName) then
            return HttpService:JSONDecode(readfile(constants.LocalDataFileName))
        end
        return {}
    end)
    return success and data or {}
end

local function saveLocalData(data)
    local success, err = pcall(function()
        writefile(constants.LocalDataFileName, HttpService:JSONEncode(data))
    end)
    return success
end

-- Функция для работы с GitHub API
local function GitHubRequest(url, method, body)
    local success, response = pcall(function()
        local headers = {
            ["Authorization"] = "token " .. state.GitHubToken,
            ["Content-Type"] = "application/json",
            ["User-Agent"] = "AutoFarmScript"
        }
        
        local request = {
            Url = "https://api.github.com" .. url,
            Method = method,
            Headers = headers
        }
        
        if body then
            request.Body = HttpService:JSONEncode(body)
        end
        
        return game:HttpGetAsync(request)
    end)
    
    if success and response then
        return HttpService:JSONDecode(response)
    end
    return nil
end

-- Функция для загрузки данных с GitHub
local function loadGitHubData()
    local success, data = pcall(function()
        local response = GitHubRequest("/repos/" .. state.GitHubRepo .. "/contents/" .. state.GitHubDataFile, "GET")
        if response and response.content then
            local content = game:HttpGet(response.download_url)
            return HttpService:JSONDecode(content)
        end
        return {}
    end)
    return success and data or {}
end

-- Функция для сохранения данных на GitHub
local function saveGitHubData(data)
    local success, result = pcall(function()
        local currentData = loadGitHubData()
        local content = HttpService:JSONEncode(data)
        local message = "Update access data - " .. os.date("%Y-%m-%d %H:%M:%S")
        
        local requestData = {
            message = message,
            content = game:HttpService:Base64Encode(content),
            sha = currentData and currentData.sha or nil
        }
        
        return GitHubRequest("/repos/" .. state.GitHubRepo .. "/contents/" .. state.GitHubDataFile, "PUT", requestData)
    end)
    return success
end

-- Функция получения информации о игроке
local function getPlayerInfo()
    local player = Players.LocalPlayer
    if player then
        return player.Name, player.UserId, player.DisplayName
    end
    return "Unknown", 0, "Unknown"
end

-- Функция создания GUI для ввода ключа
local function createKeyInputGUI(userAccessKey)
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "KeyInputGUI"
    screenGui.Parent = game:GetService("CoreGui")
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 450, 0, 300)
    frame.Position = UDim2.new(0.5, -225, 0.5, -150)
    frame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    frame.BorderSizePixel = 0
    frame.Parent = screenGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 50)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    title.Text = "Активация AutoFarm"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 18
    title.Parent = frame

    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = title

    local keyInfo = Instance.new("TextLabel")
    keyInfo.Size = UDim2.new(0.9, 0, 0, 40)
    keyInfo.Position = UDim2.new(0.05, 0, 0.15, 0)
    keyInfo.BackgroundTransparency = 1
    keyInfo.Text = "Ваш уникальный ключ доступа:"
    keyInfo.TextColor3 = Color3.fromRGB(200, 200, 200)
    keyInfo.Font = Enum.Font.Gotham
    keyInfo.TextSize = 14
    keyInfo.TextWrapped = true
    keyInfo.Parent = frame

    local keyDisplay = Instance.new("TextLabel")
    keyDisplay.Size = UDim2.new(0.9, 0, 0, 30)
    keyDisplay.Position = UDim2.new(0.05, 0, 0.25, 0)
    keyDisplay.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    keyDisplay.TextColor3 = Color3.fromRGB(0, 255, 0)
    keyDisplay.Font = Enum.Font.GothamBold
    keyDisplay.TextSize = 16
    keyDisplay.Text = userAccessKey
    keyDisplay.Parent = frame

    local keyCorner = Instance.new("UICorner")
    keyCorner.CornerRadius = UDim.new(0, 6)
    keyCorner.Parent = keyDisplay

    local instruction = Instance.new("TextLabel")
    instruction.Size = UDim2.new(0.9, 0, 0, 40)
    instruction.Position = UDim2.new(0.05, 0, 0.4, 0)
    instruction.BackgroundTransparency = 1
    instruction.Text = "Введите ваш ключ доступа для активации:"
    instruction.TextColor3 = Color3.fromRGB(200, 200, 200)
    instruction.Font = Enum.Font.Gotham
    instruction.TextSize = 14
    instruction.TextWrapped = true
    instruction.Parent = frame

    local inputBox = Instance.new("TextBox")
    inputBox.Size = UDim2.new(0.9, 0, 0, 40)
    inputBox.Position = UDim2.new(0.05, 0, 0.55, 0)
    inputBox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    inputBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    inputBox.Font = Enum.Font.Gotham
    inputBox.TextSize = 16
    inputBox.PlaceholderText = "Введите ключ доступа..."
    inputBox.Parent = frame

    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 6)
    inputCorner.Parent = inputBox

    local submitButton = Instance.new("TextButton")
    submitButton.Size = UDim2.new(0.4, 0, 0, 40)
    submitButton.Position = UDim2.new(0.3, 0, 0.75, 0)
    submitButton.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
    submitButton.Text = "Активировать"
    submitButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    submitButton.Font = Enum.Font.GothamBold
    submitButton.TextSize = 16
    submitButton.Parent = frame

    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = submitButton

    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(0.9, 0, 0, 20)
    statusLabel.Position = UDim2.new(0.05, 0, 0.9, 0)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = ""
    statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 12
    statusLabel.Parent = frame

    local function verifyKey(inputKey, correctKey)
        return inputKey:gsub("%s+", "") == correctKey:gsub("%s+", "")
    end

    submitButton.MouseButton1Click:Connect(function()
        local inputKey = inputBox.Text
        if verifyKey(inputKey, userAccessKey) then
            statusLabel.Text = "Ключ принят! Сохранение данных..."
            statusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
            
            -- Сохраняем данные пользователя
            local username, userId, displayName = getPlayerInfo()
            
            -- Обновляем локальные данные
            local localData = loadLocalData()
            local userExists = false
            
            for i, userData in ipairs(localData) do
                if userData.userId == userId then
                    localData[i] = {
                        username = username,
                        userId = userId,
                        displayName = displayName,
                        accessKey = userAccessKey,
                        keyVerified = true,
                        firstAccess = os.date("%Y-%m-%d %H:%M:%S"),
                        lastAccess = os.date("%Y-%m-%d %H:%M:%S")
                    }
                    userExists = true
                    break
                end
            end
            
            if not userExists then
                table.insert(localData, {
                    username = username,
                    userId = userId,
                    displayName = displayName,
                    accessKey = userAccessKey,
                    keyVerified = true,
                    firstAccess = os.date("%Y-%m-%d %H:%M:%S"),
                    lastAccess = os.date("%Y-%m-%d %H:%M:%S")
                })
            end
            
            if saveLocalData(localData) then
                -- Пытаемся сохранить на GitHub
                task.spawn(function()
                    local success = pcall(function()
                        local githubData = loadGitHubData()
                        local githubUserExists = false
                        
                        for i, userData in ipairs(githubData) do
                            if userData.userId == userId then
                                githubData[i] = {
                                    username = username,
                                    userId = userId,
                                    displayName = displayName,
                                    accessKey = userAccessKey,
                                    keyVerified = true,
                                    firstAccess = os.date("%Y-%m-%d %H:%M:%S"),
                                    lastAccess = os.date("%Y-%m-%d %H:%M:%S")
                                }
                                githubUserExists = true
                                break
                            end
                        end
                        
                        if not githubUserExists then
                            table.insert(githubData, {
                                username = username,
                                userId = userId,
                                displayName = displayName,
                                accessKey = userAccessKey,
                                keyVerified = true,
                                firstAccess = os.date("%Y-%m-%d %H:%M:%S"),
                                lastAccess = os.date("%Y-%m-%d %H:%M:%S")
                            })
                        end
                        
                        saveGitHubData(githubData)
                    end)
                    
                    state.KeyVerified = true
                    task.wait(1)
                    screenGui:Destroy()
                end)
            else
                statusLabel.Text = "Ошибка сохранения локальных данных!"
            end
        else
            statusLabel.Text = "Неверный ключ доступа!"
            statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        end
    end)

    inputBox.Focused:Connect(function()
        statusLabel.Text = ""
    end)

    return screenGui
end

-- Функция получения или генерации ключа для пользователя
local function getUserAccessKey()
    local username, userId, displayName = getPlayerInfo()
    
    -- Сначала проверяем GitHub
    local githubData = loadGitHubData()
    for _, userData in ipairs(githubData) do
        if userData.userId == userId then
            return userData.accessKey or generateAccessKey(userId, username)
        end
    end
    
    -- Если не нашли в GitHub, проверяем локальные данные
    local localData = loadLocalData()
    for _, userData in ipairs(localData) do
        if userData.userId == userId then
            return userData.accessKey or generateAccessKey(userId, username)
        end
    end
    
    -- Если пользователь новый, генерируем новый ключ
    return generateAccessKey(userId, username)
end

-- Функция проверки доступа пользователя
local function checkUserAccess()
    local username, userId, displayName = getPlayerInfo()
    
    -- Сначала проверяем локальные данные
    local localData = loadLocalData()
    for _, userData in ipairs(localData) do
        if userData.userId == userId then
            return userData.keyVerified or false
        end
    end
    
    -- Если не нашли локально, проверяем GitHub
    local success, githubData = pcall(loadGitHubData)
    if success and githubData then
        for _, userData in ipairs(githubData) do
            if userData.userId == userId then
                -- Обновляем локальные данные
                local updated = false
                for i, localUser in ipairs(localData) do
                    if localUser.userId == userId then
                        localData[i] = userData
                        updated = true
                        break
                    end
                end
                if not updated then
                    table.insert(localData, userData)
                end
                saveLocalData(localData)
                
                return userData.keyVerified or false
            end
        end
    end
    
    return false
end

-- Функция инициализации проверки доступа
local function initializeAccessCheck()
    if state.FirstRun then
        state.KeyVerified = checkUserAccess()
        
        if not state.KeyVerified then
            local userAccessKey = getUserAccessKey()
            local gui = createKeyInputGUI(userAccessKey)
            
            -- Ждем, пока пользователь введет ключ
            while not state.KeyVerified and settings.AutoFarmEnabled do
                task.wait(1)
            end
            
            if gui and gui.Parent then
                gui:Destroy()
            end
        end
        
        state.FirstRun = false
    end
    
    return state.KeyVerified
end

-- Функция разблокировки курсора
local function unlockCursor()
    pcall(function()
        if UserInputService.MouseBehavior ~= Enum.MouseBehavior.Default then
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        end
        if UserInputService.MouseIconEnabled == false then
            UserInputService.MouseIconEnabled = true
        end
    end)
end

-- Логирование с меткой времени
local function log(message, level)
    level = level or "INFO"
    print(string.format("[%s] [AutoFarm] [%s]: %s", os.date("%X"), level, message))
end

-- Обработчик ошибок
local function handleError(err, severity, shouldRetry)
    severity = severity or "ERROR"
    shouldRetry = shouldRetry or false
    
    log("Ошибка: " .. tostring(err), severity)
    
    if severity == "FATAL" and shouldRetry then
        state.RetryCount = state.RetryCount + 1
        if state.RetryCount <= state.MaxRetries then
            log(string.format("Попытка перезапуска %d/%d", state.RetryCount, state.MaxRetries), "WARN")
            safeDisconnectAll()
            task.wait(3)
            safeInitialize()
        else
            log("Достигнут лимит перезапусков. Скрипт остановлен.", "FATAL")
            settings.AutoFarmEnabled = false
        end
    end
end

-- Безопасное выполнение функции
local function safeCall(func, ...)
    if not settings.AutoFarmEnabled then return false end
    local success, result = pcall(func, ...)
    if not success then 
        handleError(result, "ERROR")
        return false
    end
    return result
end

-- Управление соединениями
local function manageConnection(connection, key)
    if not settings.AutoFarmEnabled then 
        if connection then 
            pcall(function() connection:Disconnect() end)
        end
        return 
    end
    
    if key and core.Connections[key] then
        pcall(function()
            core.Connections[key]:Disconnect()
        end)
    end
    
    if key and connection then
        core.Connections[key] = connection
    end
    
    return connection
end

local function safeDisconnectAll()
    for key, connection in pairs(core.Connections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            pcall(function()
                connection:Disconnect()
            end)
        end
        core.Connections[key] = nil
    end
end

-- Безопасное ожидание
local function safeWait(duration)
    if not settings.AutoFarmEnabled then return false end
    local start = tick()
    while tick() - start < duration and settings.AutoFarmEnabled do
        task.wait(0.1)
    end
    return settings.AutoFarmEnabled
end

-- Поиск в иерархии
local function findInHierarchy(parent, path)
    if not parent then return nil end
    local current = parent
    for _, name in ipairs(path) do
        current = current:FindFirstChild(name)
        if not current then return nil end
    end
    return current
end

-- Проверка ошибок
local function isTargetError(message)
    for _, pattern in ipairs(constants.ErrorPatterns) do
        if string.find(message, pattern) then
            return true
        end
    end
    return false
end

-- Настройка обработчика ошибок
local function setupErrorHandler()
    local function onErrorMessage(message, traceback, script)
        if not settings.AutoFarmEnabled then return end
        
        if isTargetError(message) then
            local currentTime = tick()
            
            if currentTime - state.LastErrorTime > settings.ErrorCooldown then
                state.ErrorCount = 0
            end
            
            state.ErrorCount = state.ErrorCount + 1
            state.LastErrorTime = currentTime
            
            log(string.format("Целевая ошибка (%d/%d): %s", 
                state.ErrorCount, settings.MaxErrors, message), "WARN")
            
            if state.ErrorCount >= settings.MaxErrors then
                state.ErrorCount = 0
                local player = Players.LocalPlayer
                if player and player.Character then
                    local humanoid = player.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        log("Слишком много ошибок! Убиваем персонажа...", "WARN")
                        pcall(function()
                            humanoid:ChangeState(Enum.HumanoidStateType.Dead)
                        end)
                    end
                end
            end
        end
    end

    manageConnection(ScriptContext.Error:Connect(onErrorMessage), "error_handler")
end

-- Проверка времени фарма
local function checkFarmTime(character)
    if not character then return false end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    
    local currentTime = tick()
    local elapsedTime = currentTime - state.FarmStartTime
    
    if elapsedTime >= settings.MaxFarmTime then
        log(string.format("Время фарма истекло (%d сек). Убиваем персонажа...", 
            math.floor(elapsedTime)), "WARN")
        pcall(function()
            humanoid:ChangeState(Enum.HumanoidStateType.Dead)
        end)
        state.FarmTimerActive = false
        return true
    end
    
    if elapsedTime >= settings.MaxFarmTime - 10 and not state.WarningShown then
        log("До окончания фарма осталось 10 секунд", "INFO")
        state.WarningShown = true
    end
    
    return false
end

-- Управление таймером фарма
local function startFarmTimer()
    state.FarmStartTime = tick()
    state.FarmTimerActive = true
    state.WarningShown = false
    log(string.format("Таймер фарма запущен (максимум %d секунд)", settings.MaxFarmTime), "INFO")
end

local function stopFarmTimer()
    if state.FarmTimerActive then
        local elapsedTime = tick() - state.FarmStartTime
        log(string.format("Таймер фарма остановлен. Прошло времени: %d секунд", 
            math.floor(elapsedTime)), "INFO")
        state.FarmTimerActive = false
        state.WarningShown = false
    end
end

-- Основная логика фарма
local function initializeAutoFarm()
    if state.Initialized then return end
    state.Initialized = true
    
    setupErrorHandler()
    
    -- Запускаем отдельный поток для разблокировки курсора
    task.spawn(function()
        while settings.AutoFarmEnabled do
            unlockCursor()
            task.wait(2)
        end
    end)
    
    -- Слушаем добавление персонажа для разблокировки курсора
    manageConnection(Players.LocalPlayer.CharacterAdded:Connect(function(character)
        task.wait(1)
        unlockCursor()
    end), "character_added_cursor")
    
    while settings.AutoFarmEnabled do
        if not state.GamePlaceId then
            while game.PlaceId == 0 and settings.AutoFarmEnabled do
                safeWait(1)
            end
            if settings.AutoFarmEnabled then
                state.GamePlaceId = game.PlaceId
                log("Определен ID игры: " .. state.GamePlaceId, "INFO")
            end
        end
        
        local isInGame = game.PlaceId == state.GamePlaceId
        
        if isInGame and settings.AutoFarmEnabled then
            log("Запуск автофарма в игре...", "INFO")
            state.IsInGame = true
            
            local success, err = pcall(function()
                local EndDecision
                local maxWaitTime = 30
                local startTime = tick()
                
                while not EndDecision and tick() - startTime < maxWaitTime and settings.AutoFarmEnabled do
                    EndDecision = findInHierarchy(ReplicatedStorage, constants.RemotesPath)
                    if not EndDecision then
                        safeWait(1)
                    end
                end
                
                if not EndDecision then
                    error("Не удалось найти EndDecision remote")
                end

                local player = Players.LocalPlayer
                if not player then return end
                
                getgenv().autoFarmBond = true
                getgenv().CollectBond = true
                
                local bondPoints = {
                    CFrame.new(-475.66, 200.77, 21969.36),
                    CFrame.new(-319.90, 200.77, 14036.94),
                    CFrame.new(-15.96, 200.77, 6099.45),
                    CFrame.new(-615.17, 200.77, -1836.15),
                    CFrame.new(249.76, 200.77, -9067.68),
                    CFrame.new(-138.72, 200.77, -17713.91),
                    CFrame.new(249.76, 200.77, -9067.68),
                    CFrame.new(228.52, 200.77, 5163.45),
                    CFrame.new(-860.02, 200.77, -27428.81),
                    CFrame.new(10.24, 200.77, -33604.30),
                    CFrame.new(-322.95, 200.77, -41545.23),
                    CFrame.new(-384.79, 40, -48746.83),
                    CFrame.new(-379.98, 3, -49471.26),
                    CFrame.new(-380.45, -23, -49332.89),
                }

                local function teleportTo(root, cf)
                    return safeCall(function()
                        if not root or not root.Parent or not root:IsA("BasePart") then 
                            return false 
                        end
                        root.Anchored = true
                        root.CFrame = cf
                        safeWait(3)
                        if root and root.Parent then
                            root.Anchored = false
                        end
                        return true
                    end)
                end

                local function tweenTo(root, cf)
                    return safeCall(function()
                        if not root or not root.Parent or not root:IsA("BasePart") then 
                            return false 
                        end
                        local distance = (root.Position - cf.Position).Magnitude
                        local duration = math.max(0.1, distance / settings.TweenSpeed)
                        local tween = TweenService:Create(root, TweenInfo.new(duration, Enum.EasingStyle.Linear), {CFrame = cf})
                        tween:Play()
                        safeWait(duration)
                        return true
                    end)
                end

                local function getLockedGunWithTimeout(timeout)
                    local startTime = tick()
                    local gunFound = false
                    local foundGun = nil
                    
                    while not gunFound and tick() - startTime < timeout and settings.AutoFarmEnabled do
                        local runtime = Workspace:FindFirstChild("RuntimeItems")
                        if runtime then
                            for _, v in ipairs(runtime:GetChildren()) do
                                if not settings.AutoFarmEnabled then break end
                                if v:IsA("Model") and v.Name == constants.GunName and v:FindFirstChild("VehicleSeat") then
                                    local seat = v:FindFirstChild("VehicleSeat")
                                    if seat and seat:IsA("VehicleSeat") then
                                        if (v:GetPivot().Position - constants.GunCFrame.Position).Magnitude <= constants.RangeMaxGun then
                                            foundGun = v
                                            gunFound = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        if not gunFound then
                            safeWait(0.5)
                        end
                    end
                    
                    return foundGun
                end

                local function sitInGun(root)
                    if not root or not root.Parent or not root:IsA("BasePart") then 
                        return false 
                    end
                    
                    local gun = getLockedGunWithTimeout(settings.GunSearchTimeout)
                    if not gun then 
                        log("Таймаут поиска пушки! Пушка не найдена за " .. settings.GunSearchTimeout .. " секунд", "WARN")
                        return false 
                    end
                    
                    local seat = gun:FindFirstChild("VehicleSeat")
                    if seat and seat:IsA("VehicleSeat") then
                        if seat.Disabled then 
                            seat.Disabled = false 
                            safeWait(0.5)
                        end
                        return teleportTo(root, seat.CFrame)
                    end
                    return false
                end

                local function jumpOff(humanoid)
                    safeCall(function()
                        if humanoid and humanoid.Parent then
                            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                        end
                    end)
                end

                local function freezeMidAir(root)
                    return safeCall(function()
                        if not root or not root.Parent or not root:IsA("BasePart") then 
                            return false 
                        end
                        root.Anchored = true
                        root.CFrame = CFrame.new(root.Position + Vector3.new(0, 5, 0))
                        safeWait(1)
                        if root and root.Parent then
                            root.Anchored = false
                        end
                        return true
                    end)
                end

                local function tryTweenToBond(root)
                    if not root or not root.Parent or not root:IsA("BasePart") then 
                        return false 
                    end
                    
                    local found = false
                    safeCall(function()
                        local runtime = Workspace:FindFirstChild("RuntimeItems")
                        if not runtime then return end
                        
                        for _, v in ipairs(runtime:GetChildren()) do
                            if not settings.AutoFarmEnabled then break end
                            if v:IsA("Model") and v.Name == constants.BondName then
                                tweenTo(root, CFrame.new(v:GetPivot().Position + Vector3.new(0, 4, 0)))
                                found = true
                                break
                            end
                        end
                    end)
                    return found
                end

                local function setupGun(root, humanoid)
                    if not root or not root.Parent or not root:IsA("BasePart") or not humanoid then 
                        return false 
                    end
                    
                    local success = safeCall(function()
                        teleportTo(root, constants.GunCFrame)
                        
                        local gunSuccess = sitInGun(root)
                        if not gunSuccess then
                            log("Не удалось сесть в пушку, убиваем персонажа...", "WARN")
                            humanoid:ChangeState(Enum.HumanoidStateType.Dead)
                            return false
                        end
                        
                        safeWait(0.6)
                        jumpOff(humanoid)
                        freezeMidAir(root)
                        safeWait(0.5)
                        
                        gunSuccess = sitInGun(root)
                        if not gunSuccess then
                            log("Не удалось сесть в пушку после прыжка, убиваем персонажа...", "WARN")
                            humanoid:ChangeState(Enum.HumanoidStateType.Dead)
                            return false
                        end
                        
                        safeWait(0.1)
                        return true
                    end)
                    
                    return success or false
                end

                -- Collect Bond
                local lastCollectTime = 0
                local activateRemote = findInHierarchy(ReplicatedStorage, constants.ActivatePath)
                
                manageConnection(RunService.Heartbeat:Connect(function()
                    if not settings.AutoFarmEnabled or not getgenv().CollectBond then return end
                    
                    local currentTime = tick()
                    if currentTime - lastCollectTime < settings.CollectDelay then return end
                    lastCollectTime = currentTime
                    
                    safeCall(function()
                        local runtime = Workspace:FindFirstChild("RuntimeItems")
                        if not runtime or not activateRemote then return end
                        
                        for _, bond in ipairs(runtime:GetChildren()) do
                            if not settings.AutoFarmEnabled then break end
                            if bond:IsA("Model") and bond.Name == constants.BondName then
                                activateRemote:FireServer(bond)
                                break
                            end
                        end
                    end)
                end), "collect_connection")

                local function farmCharacter(character)
                    if not character or not character.Parent then return end
                    
                    local startTime = tick()
                    local root, humanoid
                    
                    while tick() - startTime < 15 and settings.AutoFarmEnabled do
                        root = character:FindFirstChild("HumanoidRootPart")
                        humanoid = character:FindFirstChild("Humanoid")
                        
                        if root and humanoid and humanoid.Health > 0 then
                            break
                        end
                        safeWait(0.1)
                    end
                    
                    if not root or not humanoid or humanoid.Health <= 0 then
                        return
                    end
                    
                    startFarmTimer()
                    
                    local currentIndex = 1
                    local started = false

                    while humanoid.Health > 0 and settings.AutoFarmEnabled and state.IsInGame do
                        if checkFarmTime(character) then
                            break
                        end
                        
                        if not started then
                            local setupSuccess = setupGun(root, humanoid)
                            if not setupSuccess then
                                stopFarmTimer()
                                break
                            end
                            started = true
                        end

                        local foundBond = tryTweenToBond(root)
                        if not foundBond then
                            if currentIndex <= #bondPoints then
                                teleportTo(root, bondPoints[currentIndex])
                                currentIndex = currentIndex + 1
                            else
                                safeCall(function()
                                    if humanoid and humanoid.Parent then
                                        humanoid:ChangeState(Enum.HumanoidStateType.Dead)
                                    end
                                end)
                                stopFarmTimer()
                                break
                            end
                        end
                        safeWait(0.3)
                    end
                    
                    stopFarmTimer()
                end

                manageConnection(player.CharacterAdded:Connect(function(character)
                    if settings.AutoFarmEnabled then
                        safeWait(2)
                        farmCharacter(character)
                    end
                end), "character_added")

                if player.Character then
                    safeWait(2)
                    farmCharacter(player.Character)
                end

                local endDecisionTask
                endDecisionTask = task.spawn(function()
                    while settings.AutoFarmEnabled and state.IsInGame do
                        if getgenv().autoFarmBond then
                            safeCall(function()
                                EndDecision:FireServer(false)
                            end)
                        end
                        safeWait(0.5)
                    end
                end)

                manageConnection(Players.LocalPlayer:GetPropertyChangedSignal("UserId"):Connect(function()
                    if game.PlaceId ~= state.GamePlaceId then
                        state.IsInGame = false
                        stopFarmTimer()
                    end
                end), "userid_changed")

                while state.IsInGame and settings.AutoFarmEnabled do
                    safeWait(1)
                end

                safeDisconnectAll()
            end)
            
            if not success then
                handleError(err, "ERROR", true)
            end
        else
            log("Ожидание перехода в игру... Текущее место: " .. game.PlaceId, "INFO")
            state.IsInGame = false
            stopFarmTimer()
            safeWait(settings.CheckInterval)
        end
    end
end

-- Защищенный вызов с повторными попытками
local function protectedCallWithRetry()
    local success, err = pcall(initializeAutoFarm)
    if not success then
        handleError(err, "FATAL", true)
    end
end

-- Мониторинг изменения PlaceId
local function monitorPlaceId()
    while settings.AutoFarmEnabled do
        if state.GamePlaceId and game.PlaceId ~= 0 and game.PlaceId ~= state.GamePlaceId then
            log("Обнаружен новый PlaceId. Обновляем...", "INFO")
            state.GamePlaceId = game.PlaceId
        end
        
        if state.GamePlaceId then
            state.IsInGame = game.PlaceId == state.GamePlaceId
        end
        
        safeWait(5)
    end
end

-- Главная инициализация
local function main()
    local username, userId, displayName = getPlayerInfo()
    log(string.format("Инициализация скрипта для пользователя: %s (@%s, ID: %d)", 
        displayName, username, userId), "INFO")
    
    -- Проверяем доступ
    if not initializeAccessCheck() then
        log("Доступ не предоставлен. Скрипт остановлен.", "ERROR")
        return
    end
    
    log("Доступ подтвержден. Запуск скрипта...", "INFO")
    protectedCallWithRetry()
    task.spawn(monitorPlaceId)
end

-- Запускаем главную функцию
main()
